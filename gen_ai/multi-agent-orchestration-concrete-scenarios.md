---
created: 2026-02-06
source: claude-code
tags:
  - multi-agent
  - orchestration
  - ai-agent
  - design-pattern
---

## 시나리오 1: 병렬 독립 작업 — "처리량(Throughput)"의 문제

### 구체적 예시: 이커머스 플랫폼에 "위시리스트" 기능 추가

프론트엔드 UI, 백엔드 API, 데이터베이스 마이그레이션, 테스트가 모두 필요한 작업입니다.

### 단일 에이전트의 한계

```
단일 에이전트 (순차 처리)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[DB 스키마]──15분──▶[API 엔드포인트]──20분──▶[프론트 UI]──20분──▶[테스트]──15분

총 소요: ~70분 (순차)
문제: 각 단계가 독립적인데도 줄 서서 기다림
```

### 멀티 에이전트 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                    Orchestrator (메인 에이전트)                   │
│                                                                   │
│  1. 작업 분해: "위시리스트 기능을 4개 독립 태스크로 분리"         │
│  2. 인터페이스 계약 정의:                                        │
│     POST /api/wishlist { userId, productId }                     │
│     GET  /api/wishlist/:userId                                   │
│     DELETE /api/wishlist/:id                                     │
│  3. 병렬 서브에이전트 디스패치                                    │
│  4. 결과 수집 및 통합 검증                                       │
└──────┬──────────┬──────────┬──────────┬──────────────────────────┘
       │          │          │          │
       ▼          ▼          ▼          ▼
  ┌─────────┐┌─────────┐┌─────────┐┌─────────┐
  │ Agent-DB ││Agent-API││Agent-UI ││Agent-QA │
  │          ││         ││         ││         │
  │ 스키마   ││ Express ││ React   ││ 테스트  │
  │ 마이그   ││ 라우터  ││ 컴포넌트││ 스펙 작성│
  │ 레이션   ││ + 컨트  ││ + 훅    ││ (미리)  │
  │          ││ 롤러    ││         ││         │
  │ ~15분    ││ ~20분   ││ ~20분   ││ ~10분   │
  └─────────┘└─────────┘└─────────┘└─────────┘
       │          │          │          │
       └──────────┴──────────┴──────────┘
                      │
                      ▼
              총 소요: ~25분 (병렬)
              시간 절약: ~64%
```

### Claude Code에서의 실제 구현 흐름

Orchestrator가 하는 핵심 작업은 **인터페이스 계약을 먼저 확정**하는 것입니다:

```
Orchestrator의 사전 작업:
━━━━━━━━━━━━━━━━━━━━━━━━
1. wishlist 테이블 스키마 확정
   → { id, user_id, product_id, created_at }

2. API 계약 확정 (OpenAPI 스펙 수준)
   → POST /api/wishlist → 201 { id }
   → GET  /api/wishlist/:userId → 200 [{ id, product }]
   → DELETE /api/wishlist/:id → 204

3. 프론트 컴포넌트 인터페이스 확정
   → <WishlistButton productId={string} />
   → <WishlistPage />
   → useWishlist() hook → { items, add, remove, isLoading }
```

이 계약이 있기 때문에 각 에이전트가 **상대방의 구현을 몰라도** 자기 파트를 완성할 수 있습니다. DB 에이전트는 API 구현을 기다릴 필요 없고, UI 에이전트는 API가 완성되기 전에 hook의 인터페이스만 보고 컴포넌트를 만듭니다.

### 왜 단일 에이전트로는 부족한가

정확도 차이가 아닙니다. 단일 에이전트도 같은 품질의 코드를 만들 수 있습니다. **문제는 시간입니다.** 4개의 독립적인 파일 그룹을 순차적으로 처리하면 70분, 병렬이면 25분. 이건 정확도 벤치마크에 안 잡히는 가치입니다.

---

## 시나리오 2: 다관점 검증 — "자기 코드의 결함은 못 찾는다"

### 구체적 예시: 결제 시스템의 동시성 버그 수정

한 에이전트가 코드를 작성하고, 같은 에이전트에게 "이제 리뷰해줘"라고 하면 어떻게 될까요?

### 단일 에이전트 리뷰의 한계

```
단일 에이전트 (Self-Review)
━━━━━━━━━━━━━━━━━━━━━━━━━━━

같은 컨텍스트에서:
  "결제 처리 함수를 작성해줘" → 코드 생성
  "이제 이 코드를 리뷰해줘"  → "잘 작성되었습니다" (자기 확증 편향)

문제점:
├─ Confirmation Bias: 자기가 만든 설계 전제를 의심하지 않음
├─ 같은 컨텍스트 = 같은 "사고 패턴"에 갇힘
└─ "race condition 가능성"을 애초에 고려 안 했으면
   리뷰에서도 고려하지 않음
```

### 멀티 에이전트 아키텍처: Evaluator-Optimizer 패턴

```
┌─────────────────────────────────────────────────────────────┐
│                   Orchestrator                               │
│                                                               │
│  "결제 처리 함수의 동시성 버그를 수정하라"                    │
└──────────┬────────────────────────────────────┬──────────────┘
           │                                    │
           ▼                                    │
  ┌─────────────────────┐                       │
  │   Coder Agent        │                       │
  │                      │                       │
  │  시스템 프롬프트:     │                       │
  │  "너는 백엔드 개발자. │                       │
  │   결제 로직을 구현하라"│                       │
  │                      │                       │
  │  컨텍스트:            │                       │
  │  - payment.service.ts│                       │
  │  - 버그 리포트        │                       │
  │  - DB 스키마          │                       │
  └──────────┬───────────┘                       │
             │ 수정된 코드                        │
             ▼                                    │
  ┌─────────────────────┐                        │
  │   Reviewer Agent     │◄───────────────────────┘
  │                      │   실패 시 피드백 전달
  │  시스템 프롬프트:     │
  │  "너는 시니어 보안    │
  │   엔지니어. 다음      │──────┐
  │   관점에서 검증하라:  │      │
  │   1. Race condition  │      │  통과
  │   2. Double spending │      │
  │   3. Deadlock        │      ▼
  │   4. Error recovery" │   Orchestrator
  │                      │   → 완료 보고
  │  별도 컨텍스트:       │
  │  - 수정된 코드만      │
  │  - 체크리스트         │
  │  - 원본 코드 (diff)  │
  └──────────────────────┘
```

### 핵심: 왜 "별도 컨텍스트"가 중요한가

```
Coder Agent의 컨텍스트:            Reviewer Agent의 컨텍스트:
━━━━━━━━━━━━━━━━━━━━━━━           ━━━━━━━━━━━━━━━━━━━━━━━━━
"이 버그를 고쳐야 한다"            "이 코드에 결함이 있는가?"
→ 해결에 집중                      → 의심에 집중
→ "이렇게 하면 되겠다"             → "이게 정말 안전한가?"
→ 구현 세부사항에 몰입             → 외부 관찰자의 시선

같은 LLM이지만:
- 시스템 프롬프트가 다르고         (역할이 다름)
- 이전 대화 맥락이 없고           (선입견이 없음)
- 평가 기준이 명시되어 있음       (구조화된 검증)
```

### 구체적 발견 예시

Coder Agent가 작성한 코드:

```typescript
async function processPayment(orderId: string) {
  const order = await db.orders.findById(orderId);
  if (order.status === 'pending') {
    await paymentGateway.charge(order.amount);
    await db.orders.update(orderId, { status: 'paid' });
  }
}
```

Coder Agent 자체 리뷰: "상태 확인 후 결제 처리, 정상적으로 보입니다."

Reviewer Agent (별도 컨텍스트, 동시성 체크리스트 보유):

> "**Race Condition 발견**: `findById`와 `update` 사이에 다른 요청이 같은 주문을 처리할 수 있음. 두 요청이 동시에 `status === 'pending'`을 통과하면 **이중 결제** 발생. `SELECT ... FOR UPDATE` 또는 낙관적 잠금 필요."

이런 발견은 **코드를 작성한 에이전트와 같은 컨텍스트에서는 나오기 어렵습니다.** 작성자는 이미 "status 체크로 충분하다"는 전제로 코드를 짰기 때문입니다.

---

## 시나리오 3: 초대형 코드베이스 — "한 에이전트가 전체를 볼 수 없다"

### 구체적 예시: 12만 줄 모노레포에서 인증 체계 마이그레이션

`session 기반 인증` → `JWT + OAuth2.0`으로 전환해야 합니다. 영향 범위: 47개 파일, 8개 서비스.

### 단일 에이전트의 한계

```
전체 코드베이스: ~120,000 토큰
Claude의 컨텍스트 윈도우: ~200K 토큰 (이론상 가능)

하지만 실제로는:
━━━━━━━━━━━━━━━━
120K 토큰 로드 시:
├─ HumanEval 코딩 성능: -47.6% (30K 기준, 120K는 더 심각)
├─ Lost in the Middle: 중간에 위치한 파일의 변경점을 놓침
├─ 주의력 분산: auth 관련 코드와 무관한 90K+ 토큰이 노이즈
└─ 실제 필요한 코드: ~15K 토큰 (전체의 12.5%)

87.5%가 노이즈 → 성능 저하의 직접 원인
```

### 멀티 에이전트 아키텍처: 도메인 분할

```
┌──────────────────────────────────────────────────────────────────┐
│                     Orchestrator                                  │
│                                                                    │
│  1단계: 영향 범위 분석 (grep "session" + import graph)            │
│  2단계: 도메인별 분할                                              │
│  3단계: 공유 인터페이스 정의                                       │
│         → AuthProvider interface                                   │
│         → TokenPayload type                                        │
│         → middleware 시그니처                                       │
│  4단계: 병렬 디스패치                                              │
│  5단계: 통합 테스트                                                │
└────┬──────────┬──────────┬──────────┬──────────┬─────────────────┘
     │          │          │          │          │
     ▼          ▼          ▼          ▼          ▼
┌─────────┐┌─────────┐┌─────────┐┌─────────┐┌──────────┐
│Auth Core││API GW   ││User Svc ││Order Svc││Integ Test│
│ Agent   ││ Agent   ││ Agent   ││ Agent   ││  Agent   │
│         ││         ││         ││         ││          │
│컨텍스트: ││컨텍스트: ││컨텍스트: ││컨텍스트: ││컨텍스트:  │
│~8K 토큰 ││~6K 토큰 ││~5K 토큰 ││~7K 토큰 ││~4K 토큰  │
│         ││         ││         ││         ││          │
│• JWT    ││• 라우트 ││• 프로필 ││• 결제   ││• E2E    │
│  발급/   ││  미들웨어││  조회   ││  권한   ││  시나리오│
│  검증   ││• CORS   ││• 세션→  ││  체크   ││• 회귀   │
│• 리프레 ││• Rate   ││  토큰   ││• 세션→  ││  테스트  │
│  시 토큰 ││  Limit  ││  교체   ││  토큰   ││          │
│• OAuth  ││         ││         ││  교체   ││          │
│  플로우  ││         ││         ││         ││          │
└─────────┘└─────────┘└─────────┘└─────────┘└──────────┘
각 에이전트: 5-8K 토큰       (vs 단일 에이전트: 120K 토큰)
성능 저하:   거의 없음        (vs 단일: -47%~-59%)
```

### 핵심 메커니즘: 컨텍스트 분할의 수학

```
단일 에이전트:
  필요 코드 15K + 노이즈 105K = 120K 토큰
  신호 대 잡음비(SNR): 15/120 = 12.5%
  → "Lost in the Middle" 직격탄

멀티 에이전트 (5개):
  Agent별: 필요 코드 3K + 공유 인터페이스 2K = 5-8K 토큰
  Agent별 SNR: 3/5 ~ 3/8 = 37.5~60%
  → 각 에이전트가 자기 도메인에 집중

SNR 향상: 12.5% → 37.5~60% (3~5배 개선)
```

### Orchestrator의 통합 검증

각 에이전트가 개별 작업을 마친 후, Orchestrator가 수행하는 최종 검증:

```
통합 검증 체크리스트:
━━━━━━━━━━━━━━━━━━━
1. 인터페이스 정합성
   → Auth Core가 발급한 토큰 형식 = 각 서비스가 기대하는 형식?

2. 에러 전파 일관성
   → 토큰 만료 시 모든 서비스가 401 반환?
   → 리프레시 플로우가 모든 서비스에서 동일하게 작동?

3. 회귀 테스트
   → Integ Test Agent의 E2E 테스트 실행
   → 기존 기능이 깨지지 않았는지 확인

4. 보안 검증 (선택적으로 별도 Reviewer Agent)
   → 토큰 저장 방식 (httpOnly cookie?)
   → CSRF 보호
   → 토큰 탈취 시나리오
```

---

## 세 시나리오의 공통 패턴 정리

```
                    단일 에이전트로 충분         멀티 에이전트 필요
                    ◄──────────────────────────────────────────►

작업 독립성:   높은 의존성 ■■■■■□□□□□ 완전 독립
               (아키텍처 설계)        (프론트/백/테스트)

코드베이스:    소규모 ■■■■■□□□□□ 초대형
               (~5K 토큰)            (~100K+ 토큰)

검증 깊이:     기본 ■■■■■□□□□□ 다관점 필수
               (린트/타입체크)        (보안/동시성/성능)
```

**세 시나리오 모두 "정확도 3% 향상"이 아니라, 단일 에이전트로는 구조적으로 어려운 문제를 해결합니다.** 시간 단축(시나리오 1), 인지 편향 극복(시나리오 2), 물리적 컨텍스트 한계 극복(시나리오 3) — 이것이 벤치마크 숫자에 잡히지 않는 멀티 에이전트의 실질적 가치입니다.
